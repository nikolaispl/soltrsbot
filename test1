import os
import logging
import re
import json
import datetime
import uuid

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, MessageHandler, filters

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.cron import CronTrigger

from solana.rpc.api import Client
from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solana.rpc.types import RPCError
from solders.transaction import Transaction
from solders.system_program import transfer, TransferParams
from solders.message import Message
from solders.hash import Hash

# --- КОНСТАНТЫ И НАСТРОЙКИ ---
TELEGRAM_BOT_TOKEN = "7868719057:AAGT5S9pV7Ps4RNHMi3X-ITRqDAbBbm5sYI" # Replace with your bot token

SOLANA_RPC_URL = "https://api.devnet.solana.com" # Devnet URL

# ВАШИ НАСТРОЙКИ:
ADMIN_CHAT_IDS = [7147804089, ]  # List of user IDs allowed to control the bot
NOTIFICATION_CHAT_ID = [7147804089, -1002695168246]  # List of chat IDs for transaction notifications (can include group IDs)

# IMPORTANT: Replace with your actual sender private key bytes.
# This should be kept secure and not shared publicly.
SENDER_SECRET_KEY_BYTES = bytes([
    189, 65, 209, 10, 131, 2, 47, 120, 11, 141, 3, 53, 102, 122, 58, 159, 214, 2, 157,
    11, 29, 64, 43, 181, 96, 199, 158, 122, 116, 183, 83, 63, 103, 237, 246, 58, 94, 243,
    197, 132, 104, 33, 2, 28, 89, 201, 23, 128, 109, 102, 125, 253, 120, 107, 153, 105, 106, 195, 17, 53, 107, 136, 240,
    105
])

# Predefined recipient wallets for convenience
RECIPIENT_WALLETS_SOL = {
    "test1": PublicKey.from_string("Ezwb7DKd8aiHsju5NUQynuue7ooAn4NPqt9JwTZtu964"),
    "test2": PublicKey.from_string("HfVAWteg2kCNwkaPQqTmtfDLuKT9vfX46dx77LnFpt6v"),
    "test3": PublicKey.from_string("9S9pLPz8kWsxCQqVaiqrjTRRmiz5xEGfz35jJWS9SpKr"),
    "test4": PublicKey.from_string("7WLG4WvZCEUdWe62pYJT6o7BN1rbgfHQXg5Mmq6w8Bg4"),
    "test5": PublicKey.from_string("DZ54UDDNW1YrzApZJvsVSvyE4MWMudLAaYgMSM3pMUDA"),
}

FIXED_AMOUNTS = [0.01, 0.02, 0.03, 0.04, 0.05] # Fixed SOL amounts for quick selection

# --- НАСТРОЙКИ ЛОГГИРОВАНИЯ ---
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ДЛЯ SOLANA ---
solana_client: Client = None
wallet_keypair: Keypair = None
wallet_pubkey: PublicKey = None

# --- APSCHEDULER И НАСТРОЙКИ АВТОПЛАТЕЖЕЙ ---
scheduler = AsyncIOScheduler()
AUTO_PAYMENTS_FILE = 'auto_payments.json' # File to store auto-payment configurations

# --- ОСНОВНОЕ МЕНЮ КЛАВИАТУРА ---
main_menu_keyboard = ReplyKeyboardMarkup(
    [
        [KeyboardButton("Мой кошелек и баланс")],
        [KeyboardButton("Отправить SOL")],
        [KeyboardButton("Автооплата")]
    ],
    resize_keyboard=True, # Make the keyboard smaller
    one_time_keyboard=False # Keep the keyboard visible
)

# --- ИНИЦИАЛИЗАЦИЯ SOLANA ---
def initialize_solana():
    """Initializes the Solana client and loads the sender's keypair."""
    global solana_client, wallet_keypair, wallet_pubkey
    solana_client = Client(SOLANA_RPC_URL)
    try:
        wallet_keypair = Keypair.from_bytes(SENDER_SECRET_KEY_BYTES)
        wallet_pubkey = wallet_keypair.pubkey()
        logger.info(f"Solana initialized. Wallet: {wallet_pubkey}")
    except ValueError as e:
        logger.error(
            f"Error loading private key: {e}. Ensure SENDER_SECRET_KEY_BYTES is correct (64 bytes)."
        )
        wallet_keypair = None
        wallet_pubkey = None
    except Exception as e:
        logger.error(f"Unknown error during Solana initialization: {e}")
        wallet_keypair = None
        wallet_pubkey = None

# --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
def escape_markdown_v2(text: str) -> str:
    """Escapes special characters for MarkdownV2."""
    escape_chars = r'_*[]()~`>#+-=|{}.!\\'
    return re.sub(r'([%s])' % re.escape(escape_chars), r'\\\1', text)

def is_admin(chat_id: int) -> bool:
    """Checks if the given chat_id is an administrator."""
    return chat_id in ADMIN_CHAT_IDS

async def send_transaction_notification(application: Application, signature: str, amount: float, recipient: PublicKey,
                                       sender: PublicKey, tx_type: str = "единичный перевод") -> None:
    """Sends a transaction notification to specified chat IDs."""
    if not NOTIFICATION_CHAT_ID:
        logger.warning("NOTIFICATION_CHAT_ID is not set; no notifications will be sent.")
        return

    message = (
        f"✅ *Новая транзакция \\({escape_markdown_v2(tx_type)}\\)*\n"
        f"\\- Отправитель: `{escape_markdown_v2(str(sender))}`\n"
        f"\\- Получатель: `{escape_markdown_v2(str(recipient))}`\n"
        f"\\- Сумма: `{amount:.8f} SOL`\n"
        f"\\- Подпись: `{escape_markdown_v2(signature)}`\n"
        f"\\- Explorer: [Explorer Link](https://explorer.solana.com/tx/{escape_markdown_v2(signature)}\\?cluster=devnet)" # Klickable link
    )
    for chat_id in NOTIFICATION_CHAT_ID:
        try:
            await application.bot.send_message(chat_id, message, parse_mode='MarkdownV2')
            logger.info(f"Transaction notification {signature} sent to chat {chat_id}.")
        except Exception as e:
            logger.error(f"Failed to send transaction notification {signature} to chat {chat_id}: {e}")

async def send_multi_transaction_notification(application: Application, signatures: list[str], transactions_data: dict,
                                              sender: PublicKey) -> None:
    """Sends a notification for multiple transactions to specified chat IDs."""
    if not NOTIFICATION_CHAT_ID:
        logger.warning("NOTIFICATION_CHAT_ID is not set; no notifications will be sent.")
        return

    message = f"✅ *Новая множественная транзакция:*\n"
    total_amount = 0

    for pubkey_str, amount in transactions_data.items():
        display_name = next(
            (k for k, v in RECIPIENT_WALLETS_SOL.items() if str(v) == pubkey_str),
            pubkey_str[:4] + '...' + pubkey_str[-4:] # Shorten if not a predefined wallet
        )
        message += f"\\- `{amount:.8f} SOL` на `{escape_markdown_v2(display_name)}`\n"
        total_amount += amount

    message += f"\n\\- Отправитель: `{escape_markdown_v2(str(sender))}`\n"
    message += f"\\- Общая сумма: `{total_amount:.8f} SOL`\n"

    if signatures:
        message += f"\\- Подписи:\n"
        for sig in signatures:
            message += f"  `{escape_markdown_v2(sig)}`\n"
            message += f"  [Explorer Link](https://explorer.solana.com/tx/{escape_markdown_v2(sig)}\\?cluster=devnet)\n" # Klickable link
    else:
        message += "\\- Нет подписей транзакций \\(возможно, произошла ошибка до отправки\\)\\.\n"

    for chat_id in NOTIFICATION_CHAT_ID:
        try:
            await application.bot.send_message(chat_id, message, parse_mode='MarkdownV2')
            logger.info(f"Multi-transaction notification sent to chat {chat_id}.")
        except Exception as e:
            logger.error(f"Failed to send multi-transaction notification to chat {chat_id}: {e}")

# --- ФУНКЦИИ УПРАВЛЕНИЯ АВТОПЛАТЕЖАМИ (ЗАГРУЗКА/СОХРАНЕНИЕ) ---
def load_auto_payments():
    """Loads auto-payment data from a JSON file."""
    if os.path.exists(AUTO_PAYMENTS_FILE):
        with open(AUTO_PAYMENTS_FILE, 'r') as f:
            try:
                data = json.load(f)
                # Convert recipient_pubkey strings back to PublicKey objects
                for chat_id, payments in data.items():
                    for payment_id, details in payments.items():
                        if 'recipient_pubkey' in details and isinstance(details['recipient_pubkey'], str):
                            details['recipient_pubkey'] = PublicKey.from_string(details['recipient_pubkey'])
                return data
            except json.JSONDecodeError as e:
                logger.error(f"Error reading {AUTO_PAYMENTS_FILE}: {e}")
                return {}
    return {}

def save_auto_payments(data):
    """Saves auto-payment data to a JSON file."""
    serializable_data = {}
    for chat_id, payments in data.items():
        serializable_payments = {}
        for payment_id, details in payments.items():
            serializable_details = details.copy()
            # Convert PublicKey objects to strings for serialization
            if 'recipient_pubkey' in serializable_details:
                serializable_details['recipient_pubkey'] = str(serializable_details['recipient_pubkey'])
            serializable_payments[payment_id] = serializable_details
        serializable_data[chat_id] = serializable_payments

    with open(AUTO_PAYMENTS_FILE, 'w') as f:
        json.dump(serializable_data, f, indent=4)

# --- ГЛАВНАЯ ЛОГИКА АВТОПЛАТЕЖА ---
async def execute_auto_payment(application: Application, chat_id: int, payment_id: str):
    """Executes a single automatic payment."""
    logger.info(f"Starting auto-payment {payment_id} for chat_id {chat_id}")
    auto_payments = load_auto_payments()

    chat_payments = auto_payments.get(str(chat_id))
    if not chat_payments or payment_id not in chat_payments:
        logger.warning(f"Auto-payment {payment_id} for chat_id {chat_id} not found in data.")
        # If job exists but data is gone, remove the job
        if scheduler.get_job(f"{chat_id}_{payment_id}"):
            scheduler.remove_job(f"{chat_id}_{payment_id}")
            logger.info(f"Removed missing APScheduler job {chat_id}_{payment_id}.")
        return

    payment_details = chat_payments[payment_id]
    recipient_pubkey = payment_details['recipient_pubkey']
    amount_sol = payment_details['amount_sol']

    if not wallet_keypair or not wallet_pubkey:
        logger.error(f"Auto-payment {payment_id}: Sender wallet not initialized. Cannot execute payment.")
        await application.bot.send_message(chat_id,
            "Ошибка: Кошелек отправителя не инициализирован для автоплатежа. Пожалуйста, проверьте настройки бота."
        )
        return

    try:
        response_balance = solana_client.get_balance(wallet_pubkey)
        if not response_balance or response_balance.value is None:
            await application.bot.send_message(chat_id,
                f"Автоматический платеж {escape_markdown_v2(payment_id)} не выполнен: не удалось получить баланс. "
                "Проверьте соединение с Devnet.", parse_mode='MarkdownV2'
            )
            logger.error(f"Auto-payment {payment_id}: Failed to get balance for {wallet_pubkey}")
            return

        current_balance_lamports = response_balance.value
        current_balance_sol = current_balance_lamports / 1_000_000_000

        # Estimate transaction fee (a bit more than typical for safety)
        estimated_fee_sol = 0.000005 * 1.5
        total_needed_sol = amount_sol + estimated_fee_sol

        if current_balance_sol < total_needed_sol:
            await application.bot.send_message(chat_id,
                f"Автоматический платеж {escape_markdown_v2(payment_id)} не выполнен: недостаточно SOL\\. "
                f"Требуется: \\~`{total_needed_sol:.8f} SOL`\\, доступно: `{current_balance_sol:.8f} SOL`\\.",
                parse_mode='MarkdownV2'
            )
            logger.warning(f"Auto-payment {payment_id}: Insufficient SOL. Required: {total_needed_sol}, Available: {current_balance_sol}")
            return

        instructions = [
            transfer(
                TransferParams(
                    from_pubkey=wallet_pubkey,
                    to_pubkey=recipient_pubkey,
                    lamports=int(amount_sol * 1_000_000_000), # Convert SOL to lamports
                )
            )
        ]

        blockhash_resp = solana_client.get_latest_blockhash()
        recent_blockhash = blockhash_resp.value.blockhash

        message_obj = Message(instructions, wallet_pubkey)
        transaction = Transaction([wallet_keypair], message_obj, recent_blockhash)

        resp = solana_client.send_transaction(transaction)
        signature = resp.value

        # Update last paid timestamp and save
        payment_details['last_paid'] = datetime.datetime.now().isoformat()
        auto_payments[str(chat_id)][payment_id] = payment_details
        save_auto_payments(auto_payments)

        logger.info(f"Auto-payment {payment_id} executed, signature: {signature}")

        # Send notification about the auto-payment
        await send_transaction_notification(
            application,
            str(signature),
            amount_sol,
            recipient_pubkey,
            wallet_pubkey,
            tx_type=f"автоплатеж (ID: {escape_markdown_v2(payment_id)})" # Custom transaction type
        )

    except Exception as e:
        logger.error(f"Error executing auto-payment {payment_id}: {e}")
        await application.bot.send_message(chat_id,
            f"Ошибка выполнения автоматического платежа {escape_markdown_v2(payment_id)}: {escape_markdown_v2(str(e))}",
            parse_mode='MarkdownV2'
        )

async def schedule_all_auto_payments(application: Application):
    """Schedules all auto-payments loaded from the file."""
    auto_payments_data = load_auto_payments()
    for chat_id_str, payments in auto_payments_data.items():
        chat_id = int(chat_id_str)
        for payment_id, details in payments.items():
            recipient_pubkey = details['recipient_pubkey']
            amount_sol = details['amount_sol']
            schedule_info = details['schedule']

            job_id = f"{chat_id}_{payment_id}"

            # Check if job already exists to prevent duplicates on restart
            if scheduler.get_job(job_id):
                logger.info(f"APScheduler job {job_id} already exists, skipping re-addition.")
                continue

            if schedule_info['type'] == 'interval':
                minutes = int(schedule_info['value'])
                scheduler.add_job(
                    execute_auto_payment,
                    IntervalTrigger(minutes=minutes),
                    args=[application, chat_id, payment_id],
                    id=job_id,
                    replace_existing=True # Replace if a job with same ID exists (e.g., after manual edit)
                )
                logger.info(f"Scheduled auto-payment {job_id}: {amount_sol} SOL to {recipient_pubkey} every {minutes} minutes.")
            elif schedule_info['type'] == 'daily':
                hour, minute = map(int, schedule_info['value'].split(':'))
                scheduler.add_job(
                    execute_auto_payment,
                    CronTrigger(hour=hour, minute=minute),
                    args=[application, chat_id, payment_id],
                    id=job_id,
                    replace_existing=True
                )
                logger.info(f"Scheduled auto-payment {job_id}: {amount_sol} SOL to {recipient_pubkey} daily at {schedule_info['value']}.")
            elif schedule_info['type'] == 'monthly':
                day, time_str = schedule_info['value'].split(' ', 1)
                day = int(day)
                hour, minute = map(int, time_str.split(':'))
                scheduler.add_job(
                    execute_auto_payment,
                    CronTrigger(day=day, hour=hour, minute=minute),
                    args=[application, chat_id, payment_id],
                    id=job_id,
                    replace_existing=True
                )
                logger.info(f"Scheduled auto-payment {job_id}: {amount_sol} SOL to {recipient_pubkey} monthly on day {day} at {hour}:{minute}.")
    logger.info("All existing auto-payments loaded and scheduled.")

# --- TELEGRAM BOT HANDLERS ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles the /start command."""
    if not is_admin(update.effective_chat.id):
        await update.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return

    user = update.effective_user
    await update.message.reply_html(
        f"Привет, {user.mention_html()}! Я ваш бот для Devnet Solana.\n"
        "Выберите действие ниже:",
        reply_markup=main_menu_keyboard
    )

async def handle_main_menu_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles main menu button presses."""
    if not is_admin(update.effective_chat.id):
        await update.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return

    text = update.message.text

    if text == "Мой кошелек и баланс":
        await show_wallet_info(update.message, context)
    elif text == "Отправить SOL":
        await choose_send_method(update.message, context)
    elif text == "Автооплата":
        await auto_payment_menu(update.message, context)
    else:
        # If text is not a known button, it might be an input for amount/address
        await handle_amount_or_address_input(update, context)

async def show_wallet_info(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays the sender's wallet address and current balance."""
    if not wallet_pubkey:
        await message.reply_text("Ошибка: Кошелек не инициализирован. Проверьте конфигурацию.", reply_markup=main_menu_keyboard)
        logger.error("Attempted to show wallet/balance, but wallet_pubkey is not initialized.")
        return

    wallet_address_text = f"Адрес вашего кошелька:\n`{escape_markdown_v2(str(wallet_pubkey))}`"

    await message.reply_text("Получаю ваш баланс SOL. Пожалуйста, подождите...", reply_markup=main_menu_keyboard)
    logger.info(f"Requesting balance for wallet: {wallet_pubkey}")

    try:
        response = solana_client.get_balance(wallet_pubkey)

        if response and response.value is not None:
            balance_lamports = response.value
            balance_sol = balance_lamports / 1_000_000_000
            balance_text = f"Ваш текущий баланс SOL:\n`{balance_sol:.8f} SOL`"
            full_info_text = f"{wallet_address_text}\n\n{balance_text}"
            await message.reply_text(full_info_text, parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
            logger.info(f"Balance for {wallet_pubkey}: {balance_sol} SOL")
        else:
            await message.reply_text(
                "Не удалось получить баланс. Возможно, аккаунт не найден или произошла ошибка RPC.",
                reply_markup=main_menu_keyboard)
            logger.error(f"Invalid get_balance response for {wallet_pubkey}: {response}")

    except RPCError as e:
        await message.reply_text(
            f"Ошибка RPC при получении баланса: `{escape_markdown_v2(str(e))}`\\. Проверьте адрес кошелька или соединение с Devnet\\.",
            parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        logger.error(f"RPC Error getting balance for {wallet_pubkey}: {e}")
    except Exception as e:
        await message.reply_text(f"Произошла непредвиденная ошибка при получении баланса: `{escape_markdown_v2(str(e))}`", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        logger.error(f"Unexpected error getting balance for {wallet_pubkey}: {e}")

async def choose_send_method(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Allows choosing how to send SOL (single, manual, or multiple)."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return

    keyboard_buttons = [
        [InlineKeyboardButton("На один из тестовых кошельков", callback_data="send_method_single")],
        [InlineKeyboardButton("На другой кошелек (вручную)", callback_data="send_method_manual")],
        [InlineKeyboardButton("Выбрать несколько кошельков", callback_data="send_method_multiple")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message.reply_text("Как вы хотите отправить SOL?", reply_markup=reply_markup)

async def choose_single_recipient(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays a list of predefined recipients for single transfers."""
    if not is_admin(update.effective_chat.id):
        await update.callback_query.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    keyboard_buttons = []
    for key, value in RECIPIENT_WALLETS_SOL.items():
        keyboard_buttons.append([InlineKeyboardButton(f"На {key} ({str(value)[:4]}...{str(value)[-4:]})", callback_data=f"select_recipient_{key}")])

    keyboard_buttons.append([InlineKeyboardButton("На ВСЕ кошельки", callback_data="select_recipient_all")])

    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await update.callback_query.message.reply_text("Выберите, куда отправить SOL (единичный перевод):", reply_markup=reply_markup)

async def choose_multiple_recipients(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Starts the multi-recipient selection process."""
    if not is_admin(update.effective_chat.id):
        await update.callback_query.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    context.user_data['multi_send_targets'] = {} # Stores {pubkey_str: amount_sol}
    context.user_data['multi_send_step'] = 'selecting_wallets'
    context.user_data['current_wallet_for_amount'] = None

    keyboard_buttons = []
    for key, value in RECIPIENT_WALLETS_SOL.items():
        keyboard_buttons.append([InlineKeyboardButton(f"Выбрать {key} ({str(value)[:4]}...{str(value)[-4:]})", callback_data=f"multi_select_wallet_{key}")])

    keyboard_buttons.append([InlineKeyboardButton("Завершить выбор кошельков", callback_data="multi_select_done")])

    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await update.callback_query.message.reply_text("Выберите кошельки для отправки SOL (можно выбрать несколько, затем 'Готово'):", reply_markup=reply_markup)


async def choose_amount(update: Update, context: ContextTypes.DEFAULT_TYPE, recipient_key: str = None) -> None:
    """Asks the user to choose or input an amount of SOL."""
    message_text = ""
    message_to_reply_to = update.callback_query.message if update.callback_query else update.message

    if context.user_data.get('multi_send_step') == 'requesting_amounts':
        current_pubkey_str = context.user_data['current_wallet_for_amount']
        recipient_display_name = next(
            (k for k, v in RECIPIENT_WALLETS_SOL.items() if str(v) == current_pubkey_str),
            current_pubkey_str[:4] + '...' + current_pubkey_str[-4:]
        )
        message_text = f"Для кошелька `{escape_markdown_v2(recipient_display_name)}` выберите сумму из списка или введите свою:"
    elif context.user_data.get('auto_payment_step') == 'amount':
        recipient_display_name = context.user_data['temp_auto_payment_recipient_display']
        message_text = f"Для кошелька `{escape_markdown_v2(recipient_display_name)}` выберите сумму для автоплатежа или введите свою:"
    else:
        if recipient_key:
            context.user_data['selected_recipient_key'] = recipient_key
            message_text = f"Вы выбрали '{escape_markdown_v2(recipient_key.replace('_', ' '))}'\\. Теперь выберите сумму из списка или введите свою:"
        else:
            message_text = "Выберите сумму из списка или введите свою:"


    keyboard_buttons = []
    for amount in FIXED_AMOUNTS:
        keyboard_buttons.append(InlineKeyboardButton(f"{amount} SOL", callback_data=f"send_amount_{amount}"))

    rows = [keyboard_buttons[i:i + 3] for i in range(0, len(keyboard_buttons), 3)] # Arrange into rows of 3

    reply_markup = InlineKeyboardMarkup(rows)
    await message_to_reply_to.reply_text(
        message_text,
        parse_mode='MarkdownV2',
        reply_markup=reply_markup
    )

async def inline_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles all inline button presses."""
    query = update.callback_query
    await query.answer() # Acknowledge the callback query

    # Admin check at the very beginning of the handler
    if not is_admin(update.effective_chat.id):
        await query.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return

    if query.data == "send_method_single":
        await choose_single_recipient(update, context)
    elif query.data == "send_method_manual":
        context.user_data['send_method'] = 'manual'
        await query.message.reply_text("Пожалуйста, введите адрес кошелька получателя:")
    elif query.data == "send_method_multiple":
        await choose_multiple_recipients(update, context)
    elif query.data.startswith("select_recipient_"):
        recipient_key = query.data.replace("select_recipient_", "")
        context.user_data['send_method'] = 'single'
        await choose_amount(update, context, recipient_key)
    elif query.data.startswith("multi_select_wallet_"):
        selected_key = query.data.replace("multi_select_wallet_", "")
        pubkey_obj = RECIPIENT_WALLETS_SOL.get(selected_key)
        if pubkey_obj:
            if str(pubkey_obj) in context.user_data['multi_send_targets']:
                # Deselect if already selected
                del context.user_data['multi_send_targets'][str(pubkey_obj)]
                await query.message.edit_reply_markup(reply_markup=build_multi_select_keyboard(context.user_data['multi_send_targets']))
                await query.message.reply_text(f"Кошелек {escape_markdown_v2(selected_key)} удален из списка\\. Выберите еще или 'Завершить выбор кошельков'\\.", parse_mode='MarkdownV2')
            else:
                # Select if not selected
                context.user_data['multi_send_targets'][str(pubkey_obj)] = 0 # Initialize amount to 0
                await query.message.edit_reply_markup(reply_markup=build_multi_select_keyboard(context.user_data['multi_send_targets']))
                await query.message.reply_text(f"Кошелек {escape_markdown_v2(selected_key)} добавлен в список\\. Выберите еще или 'Завершить выбор кошельков'\\.", parse_mode='MarkdownV2')
        else:
            await query.message.reply_text("Неизвестный кошелек\\. Пожалуйста, выберите из списка\\.", reply_markup=main_menu_keyboard)
    elif query.data == "multi_select_done":
        if not context.user_data['multi_send_targets']:
            await query.message.reply_text("Вы не выбрали ни один кошелек\\. Пожалуйста, выберите хотя бы один\\. Или нажмите 'Отправить SOL' еще раз\\.", reply_markup=main_menu_keyboard)
            # Clear multi-send state
            context.user_data.pop('multi_send_step', None)
            context.user_data.pop('multi_send_targets', None)
            context.user_data.pop('current_wallet_for_amount', None)
            return

        context.user_data['multi_send_step'] = 'requesting_amounts'
        # Convert dict keys to list to pop them one by one
        context.user_data['remaining_wallets_for_amount'] = list(context.user_data['multi_send_targets'].keys())
        await request_next_amount(update, context)
    elif query.data == "confirm_multi_send_final":
        await final_multi_send(query.message, context)
    elif query.data.startswith("send_amount_"):
        amount_sol = float(query.data.replace("send_amount_", ""))
        if context.user_data.get('auto_payment_step') == 'amount':
            context.user_data['temp_auto_payment_amount'] = amount_sol
            await request_auto_payment_schedule(query.message, context)
        else:
            await process_amount_input(update, context, amount_sol)
    elif query.data == "auto_add_from_list":
        await auto_add_from_list(query.message, context)
    elif query.data == "auto_add_manual":
        context.user_data['auto_payment_step'] = 'recipient_manual'
        await query.message.reply_text("Пожалуйста, введите адрес кошелька для автоплатежа:")
    elif query.data == "auto_list_payments":
        await list_auto_payments(query.message, context)
    elif query.data == "auto_remove_payment":
        await remove_auto_payment_prompt(query.message, context)
    elif query.data.startswith("auto_select_recipient_"):
        recipient_key = query.data.replace("auto_select_recipient_", "")
        pubkey_obj = RECIPIENT_WALLETS_SOL.get(recipient_key)
        if pubkey_obj:
            context.user_data['temp_auto_payment_recipient_pubkey'] = str(pubkey_obj)
            context.user_data['temp_auto_payment_recipient_display'] = recipient_key # Store friendly name
            context.user_data['auto_payment_step'] = 'amount'
            await choose_amount(update, context)
        else:
            await query.message.reply_text("Неизвестный кошелек\\. Пожалуйста, выберите из списка\\.", reply_markup=main_menu_keyboard)
    elif query.data.startswith("auto_schedule_"):
        schedule_type = query.data.replace("auto_schedule_", "")
        context.user_data['temp_auto_payment_schedule_type'] = schedule_type
        await request_schedule_value(query.message, context)
    elif query.data.startswith("confirm_auto_payment_"):
        payment_id = query.data.replace("confirm_auto_payment_", "")
        # Validate that the payment_id matches the one stored in user_data
        if context.user_data.get('temp_auto_payment_id') == payment_id:
            await confirm_add_auto_payment(query.message, context, payment_id)
        else:
            await query.message.reply_text("Ошибка подтверждения\\. Идентификатор платежа не совпадает\\. Пожалуйста, попробуйте начать сначала или используйте меню\\.", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
    elif query.data.startswith("delete_auto_payment_"):
        payment_id_to_delete = query.data.replace("delete_auto_payment_", "")
        await delete_auto_payment(query.message, context, payment_id_to_delete)
    else:
        await query.message.reply_text("Неизвестное действие. Пожалуйста, используйте меню.", reply_markup=main_menu_keyboard)


def build_multi_select_keyboard(selected_wallets: dict) -> InlineKeyboardMarkup:
    """Builds the inline keyboard for multi-wallet selection, indicating selected ones."""
    keyboard_buttons = []
    for key, value in RECIPIENT_WALLETS_SOL.items():
        text = f"Выбрать {key} ({str(value)[:4]}...{str(value)[-4:]})"
        if str(value) in selected_wallets:
            text += " ✅" # Add a checkmark if already selected
        keyboard_buttons.append([InlineKeyboardButton(text, callback_data=f"multi_select_wallet_{key}")])

    keyboard_buttons.append([InlineKeyboardButton("Завершить выбор кошельков", callback_data="multi_select_done")])
    return InlineKeyboardMarkup(keyboard_buttons)


async def request_next_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Asks for the amount for the next wallet in multi-send, or proceeds to confirmation."""
    if context.user_data['remaining_wallets_for_amount']:
        current_pubkey_str = context.user_data['remaining_wallets_for_amount'].pop(0)
        context.user_data['current_wallet_for_amount'] = current_pubkey_str

        await choose_amount(update, context)
    else:
        # All amounts requested, proceed to final confirmation
        message_to_use = update.callback_query.message if update.callback_query else update.message
        await confirm_multi_send(message_to_use, context)


async def confirm_multi_send(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays a confirmation message for multiple transfers before execution."""
    total_amount_sol = sum(context.user_data['multi_send_targets'].values())

    confirmation_text = "Вы собираетесь отправить:\n\n"
    num_recipients = len(context.user_data['multi_send_targets'])

    for pubkey_str, amount in context.user_data['multi_send_targets'].items():
        display_name = next(
            (k for k, v in RECIPIENT_WALLETS_SOL.items() if str(v) == pubkey_str),
            pubkey_str[:4] + '...' + pubkey_str[-4:]
        )
        confirmation_text += f"\\- `{amount:.8f} SOL` на `{escape_markdown_v2(display_name)}`\n"

    confirmation_text += f"\nОбщая сумма \\(без комиссии\\): `{total_amount_sol:.8f} SOL`\n"

    # Estimate fee based on number of instructions (recipients)
    estimated_fee_sol = 0.000005 * num_recipients * 1.5
    confirmation_text += f"Примерная комиссия: \\~`{estimated_fee_sol:.8f} SOL`\n"
    confirmation_text += "\nПодтверждаете отправку?"

    keyboard = [[InlineKeyboardButton("Подтвердить", callback_data="confirm_multi_send_final")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message.reply_text(confirmation_text, parse_mode='MarkdownV2', reply_markup=reply_markup)

async def handle_amount_or_address_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles text input from the user (for amounts or addresses)."""
    if not is_admin(update.effective_chat.id):
        await update.message.reply_text("Извините, у вас нет доступа к этому боту.")
        return

    message = update.message
    send_method = context.user_data.get('send_method')
    current_step = context.user_data.get('multi_send_step')
    auto_payment_step = context.user_data.get('auto_payment_step')

    # Handle manual recipient address input
    if send_method == 'manual':
        try:
            recipient_pubkey_manual = PublicKey.from_string(message.text)
            context.user_data['selected_recipient_manual_pubkey'] = recipient_pubkey_manual
            context.user_data['send_method'] = 'manual_amount' # Move to next step: amount
            await message.reply_text("Адрес принят\\. Теперь введите сумму SOL для отправки \\(например, 0\\.01\\)\\.", parse_mode='MarkdownV2')
        except Exception:
            await message.reply_text("Неверный формат адреса\\. Пожалуйста, введите корректный адрес Solana\\.", reply_markup=main_menu_keyboard)
        return

    # Handle manual amount input after manual address
    if send_method == 'manual_amount':
        try:
            amount_sol = float(message.text)
            if amount_sol <= 0:
                await message.reply_text("Сумма должна быть положительной. Пожалуйста, попробуйте еще раз.", reply_markup=main_menu_keyboard)
                return

            recipient_pubkey = context.user_data.pop('selected_recipient_manual_pubkey')
            context.user_data.pop('send_method') # Clear state
            await send_sol_to_recipients(message, context, [recipient_pubkey], amount_sol, tx_type="ручной перевод")
        except ValueError:
            await message.reply_text("Неверный формат суммы. Пожалуйста, введите число (например, 0.01).", reply_markup=main_menu_keyboard)
        except Exception as e:
            logger.error(f"Error processing manual amount input: {e}")
            await message.reply_text(f"Произошла ошибка: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    # Handle amount input for multi-send
    if current_step == 'requesting_amounts':
        try:
            amount_sol = float(message.text)
            if amount_sol <= 0:
                await message.reply_text("Сумма должна быть положительной. Пожалуйста, попробуйте еще раз.", reply_markup=main_menu_keyboard)
                return

            current_pubkey_str = context.user_data.pop('current_wallet_for_amount')
            context.user_data['multi_send_targets'][current_pubkey_str] = amount_sol

            await request_next_amount(update, context) # Request amount for next wallet or confirm
        except ValueError:
            await message.reply_text("Неверный формат суммы. Пожалуйста, введите число (например, 0.01).", reply_markup=main_menu_keyboard)
        except Exception as e:
            logger.error(f"Error processing manual amount input for multi-send: {e}")
            await message.reply_text(f"Произошла ошибка: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    # Handle manual recipient address input for auto-payment
    if auto_payment_step == 'recipient_manual':
        try:
            recipient_pubkey_manual = PublicKey.from_string(message.text)
            context.user_data['temp_auto_payment_recipient_pubkey'] = str(recipient_pubkey_manual)
            context.user_data['temp_auto_payment_recipient_display'] = str(recipient_pubkey_manual)[:4] + '...' + str(recipient_pubkey_manual)[-4:]
            context.user_data['auto_payment_step'] = 'amount'
            await choose_amount(update, context)
        except Exception:
            await message.reply_text("Неверный формат адреса\\. Пожалуйста, введите корректный адрес Solana для автоплатежа\\.", reply_markup=main_menu_keyboard)
        return

    # Handle manual amount input for auto-payment
    if auto_payment_step == 'amount':
        try:
            amount_sol = float(message.text)
            if amount_sol <= 0:
                await message.reply_text("Сумма должна быть положительной. Пожалуйста, попробуйте еще раз.", reply_markup=main_menu_keyboard)
                return

            context.user_data['temp_auto_payment_amount'] = amount_sol
            await request_auto_payment_schedule(message, context)
        except ValueError:
            await message.reply_text("Неверный формат суммы. Пожалуйста, введите число (например, 0.01).", reply_markup=main_menu_keyboard)
        except Exception as e:
            logger.error(f"Error processing manual amount input for auto-payment: {e}")
            await message.reply_text(f"Произошла ошибка: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    # Handle schedule value input for auto-payment
    if auto_payment_step == 'schedule_value':
        schedule_type = context.user_data['temp_auto_payment_schedule_type']
        schedule_value_raw = message.text.strip()

        try:
            if schedule_type == 'interval':
                minutes = int(schedule_value_raw)
                if minutes <= 0: raise ValueError("Минуты должны быть положительными.")
                context.user_data['temp_auto_payment_schedule_value'] = str(minutes)
                context.user_data['temp_auto_payment_schedule_display'] = f"каждые {minutes} минут"
            elif schedule_type == 'daily':
                if not re.fullmatch(r"([01]?\d|2[0-3]):([0-5]?\d)", schedule_value_raw):
                    raise ValueError("Неверный формат времени. Используйте ЧЧ:ММ (например, 14:30).")
                context.user_data['temp_auto_payment_schedule_value'] = schedule_value_raw
                context.user_data['temp_auto_payment_schedule_display'] = f"ежедневно в {schedule_value_raw}"
            elif schedule_type == 'monthly':
                parts = schedule_value_raw.split()
                if len(parts) != 2: raise ValueError("Неверный формат. Используйте 'день ЧЧ:ММ' (например, '15 10:30').")
                day = int(parts[0])
                if not (1 <= day <= 31): raise ValueError("День месяца должен быть от 1 до 31.")
                time_str = parts[1]
                if not re.fullmatch(r"([01]?\d|2[0-3]):([0-5]?\d)", time_str):
                    raise ValueError("Неверный формат времени. Используйте ЧЧ:ММ (например, 14:30).")

                context.user_data['temp_auto_payment_schedule_value'] = f"{day} {time_str}"
                context.user_data['temp_auto_payment_schedule_display'] = f"ежемесячно {day} числа в {time_str}"
            else:
                raise ValueError("Неизвестный тип расписания.")

            await confirm_add_auto_payment_details(message, context) # Go to confirmation step

        except ValueError as e:
            await message.reply_text(f"Ошибка ввода расписания: {escape_markdown_v2(str(e))}\\. Пожалуйста, попробуйте еще раз\\.", parse_mode='MarkdownV2')
            context.user_data['auto_payment_step'] = 'schedule_value' # Keep in this step for re-input
        except Exception as e:
            logger.error(f"Unexpected error during auto-payment schedule input: {e}")
            await message.reply_text(f"Произошла непредвиденная ошибка: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    # Fallback for single send amount if not handled by inline buttons
    if context.user_data.get('send_method') == 'single' and context.user_data.get('selected_recipient_key'):
        await process_amount_input(update, context, message.text)
        return

    await message.reply_text("Неизвестное действие. Пожалуйста, используйте меню.", reply_markup=main_menu_keyboard)


async def process_amount_input(update: Update, context: ContextTypes.DEFAULT_TYPE, amount_input) -> None:
    """Processes the entered SOL amount and proceeds to send."""
    try:
        amount_sol = float(amount_input)
        if amount_sol <= 0:
            message_to_reply_to = update.callback_query.message if update.callback_query else update.message
            await message_to_reply_to.reply_text("Сумма должна быть положительной. Пожалуйста, попробуйте еще раз.", reply_markup=main_menu_keyboard)
            return

        send_method = context.user_data.get('send_method')
        current_step = context.user_data.get('multi_send_step')

        message_to_use_for_final_replies = update.callback_query.message if update.callback_query else update.message

        recipients = []
        if send_method == 'single':
            recipient_key = context.user_data.pop('selected_recipient_key')
            if recipient_key == "all":
                recipients.extend(RECIPIENT_WALLETS_SOL.values())
            elif recipient_key in RECIPIENT_WALLETS_SOL:
                recipients.append(RECIPIENT_WALLETS_SOL[recipient_key])
            else:
                await message_to_use_for_final_replies.reply_text("Неизвестный получатель.", reply_markup=main_menu_keyboard)
                return
            context.user_data.pop('send_method') # Clear state
            await send_sol_to_recipients(message_to_use_for_final_replies, context, recipients, amount_sol, tx_type="единичный перевод")
        elif current_step == 'requesting_amounts':
            # This branch is for processing amount for multi-send, not for final send
            current_pubkey_str = context.user_data.pop('current_wallet_for_amount')
            context.user_data['multi_send_targets'][current_pubkey_str] = amount_sol

            await request_next_amount(update, context) # Move to next wallet or confirmation
        else:
            await message_to_use_for_final_replies.reply_text("Ошибка в логике определения получателя/суммы.", reply_markup=main_menu_keyboard)

    except ValueError:
        message_to_reply_to = update.callback_query.message if update.callback_query else update.message
        await message_to_reply_to.reply_text("Неверный формат суммы. Пожалуйста, введите число (например, 0.01).", reply_markup=main_menu_keyboard)
    except Exception as e:
        logger.error(f"Error processing SOL amount: {e}")
        message_to_reply_to = update.callback_query.message if update.callback_query else update.message
        await message_to_reply_to.reply_text(f"Произошла ошибка при обработке суммы: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)


async def send_sol_to_recipients(message, context: ContextTypes.DEFAULT_TYPE, recipients: list[PublicKey],
                                 amount_sol: float, tx_type: str = "единичный перевод") -> None:
    """Sends SOL to one or more recipients."""
    if not wallet_keypair or not wallet_pubkey:
        await message.reply_text("Ошибка: Кошелек отправителя не инициализирован.", reply_markup=main_menu_keyboard)
        logger.error("Attempted SOL transfer, but wallet_keypair or wallet_pubkey is not initialized.")
        return

    try:
        response_balance = solana_client.get_balance(wallet_pubkey)
        if not response_balance or response_balance.value is None:
            await message.reply_text("Не удалось получить текущий баланс SOL для проверки.", reply_markup=main_menu_keyboard)
            return

        current_balance_lamports = response_balance.value
        current_balance_sol = current_balance_lamports / 1_000_000_000
        logger.info(f"Current sender balance: {current_balance_sol} SOL")

        # Estimate fee based on number of recipients (instructions)
        estimated_fee_sol = 0.000005 * len(recipients) * 1.5

        total_amount_needed_sol = (amount_sol * len(recipients)) + estimated_fee_sol

        if current_balance_sol < total_amount_needed_sol:
            await message.reply_text(
                f"Недостаточный баланс SOL\\. Требуется: \\~`{total_amount_needed_sol:.8f} SOL` \\(включая комиссию\\), доступно: `{current_balance_sol:.8f} SOL`\\.",
                parse_mode='MarkdownV2',
                reply_markup=main_menu_keyboard)
            logger.warning(f"Insufficient SOL. Required: {total_amount_needed_sol}, Available: {current_balance_sol}")
            return

    except Exception as e:
        logger.error(f"Error checking balance before SOL transfer: {e}")
        await message.reply_text(f"Ошибка при проверке баланса: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    instructions = []
    for recipient_pubkey in recipients:
        amount_lamports = int(amount_sol * 1_000_000_000)
        instructions.append(
            transfer(
                TransferParams(
                    from_pubkey=wallet_pubkey,
                    to_pubkey=recipient_pubkey,
                    lamports=amount_lamports,
                )
            )
        )

    if not instructions:
        await message.reply_text("Не удалось сгенерировать инструкции для перевода SOL.", reply_markup=main_menu_keyboard)
        return

    try:
        blockhash_resp = solana_client.get_latest_blockhash()
        recent_blockhash = blockhash_resp.value.blockhash

        message_obj = Message(instructions, wallet_pubkey)
        transaction = Transaction([wallet_keypair], message_obj, recent_blockhash)

        logger.info("Sending SOL transaction...")
        resp = solana_client.send_transaction(transaction)
        signature = resp.value

        logger.info(f"SOL transaction sent, signature: {signature}")

        await message.reply_text(f"Транзакция SOL отправлена\\! Подпись: `{escape_markdown_v2(str(signature))}`\n"
                                 f"Посмотреть в Explorer: `https://explorer.solana.com/tx/{escape_markdown_v2(str(signature))}\\?cluster=devnet`",
                                 parse_mode='MarkdownV2',
                                 reply_markup=main_menu_keyboard)
        # Send notification about the single transaction
        # For "send to all" case, each will be notified as a separate transaction
        for recipient_pubkey in recipients:
             await send_transaction_notification(
                 context.application,
                 str(signature),
                 amount_sol,
                 recipient_pubkey,
                 wallet_pubkey,
                 tx_type=tx_type
             )


    except Exception as e:
        logger.error(f"Error sending SOL transaction: {e}")
        await message.reply_text(f"Произошла ошибка при отправке транзакции SOL: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)

async def final_multi_send(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Executes the aggregated multiple SOL transfers."""
    if not wallet_keypair or not wallet_pubkey:
        await message.reply_text("Ошибка: Кошелек отправителя не инициализирован.", reply_markup=main_menu_keyboard)
        logger.error("Attempted multi-SOL transfer, but wallet_keypair or wallet_pubkey is not initialized.")
        return

    multi_send_data = context.user_data.pop('multi_send_targets', {})
    context.user_data.pop('multi_send_step', None)
    context.user_data.pop('current_wallet_for_amount', None)

    if not multi_send_data:
        await message.reply_text("Нет данных для множественной отправки.", reply_markup=main_menu_keyboard)
        return

    instructions = []
    total_requested_sol = 0
    for pubkey_str, amount_sol in multi_send_data.items():
        recipient_pubkey = PublicKey.from_string(pubkey_str)
        amount_lamports = int(amount_sol * 1_000_000_000)
        instructions.append(
            transfer(
                TransferParams(
                    from_pubkey=wallet_pubkey,
                    to_pubkey=recipient_pubkey,
                    lamports=amount_lamports,
                )
            )
        )
        total_requested_sol += amount_sol

    try:
        response_balance = solana_client.get_balance(wallet_pubkey)
        current_balance_lamports = response_balance.value
        current_balance_sol = current_balance_lamports / 1_000_000_000

        estimated_fee_sol = 0.000005 * len(instructions) * 1.5
        total_needed_sol = total_requested_sol + estimated_fee_sol

        if current_balance_sol < total_needed_sol:
            await message.reply_text(
                f"Недостаточный баланс SOL\\. Требуется: \\~`{total_needed_sol:.8f} SOL` \\(включая комиссию\\), доступно: `{current_balance_sol:.8f} SOL`\\.",
                parse_mode='MarkdownV2',
                reply_markup=main_menu_keyboard)
            logger.warning(f"Insufficient SOL. Required: {total_needed_sol}, Available: {current_balance_sol}")
            return

        blockhash_resp = solana_client.get_latest_blockhash()
        recent_blockhash = blockhash_resp.value.blockhash

        message_obj = Message(instructions, wallet_pubkey)
        transaction = Transaction([wallet_keypair], message_obj, recent_blockhash)

        logger.info("Sending multiple SOL transactions...")
        resp = solana_client.send_transaction(transaction)
        signature = resp.value

        logger.info(f"Multiple SOL transaction sent, signature: {signature}")

        await message.reply_text(f"Множественная транзакция SOL отправлена\\! Подпись: `{escape_markdown_v2(str(signature))}`\n"
                                 f"Посмотреть в Explorer: `https://explorer.solana.com/tx/{escape_markdown_v2(str(signature))}\\?cluster=devnet`",
                                 parse_mode='MarkdownV2',
                                 reply_markup=main_menu_keyboard)
        # Send notification about the multi-transaction
        await send_multi_transaction_notification(
            context.application,
            [str(signature)], # Pass the list of signatures (one in this case)
            multi_send_data,
            wallet_pubkey
        )

    except Exception as e:
        logger.error(f"Error sending multiple SOL transactions: {e}")
        await message.reply_text(f"Произошла ошибка при отправке нескольких транзакций SOL: {escape_markdown_v2(str(e))}", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)

async def auto_payment_menu(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays the auto-payment menu options."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    keyboard_buttons = [
        [InlineKeyboardButton("Добавить из списка", callback_data="auto_add_from_list")],
        [InlineKeyboardButton("Добавить вручную", callback_data="auto_add_manual")],
        [InlineKeyboardButton("Список автоплатежей", callback_data="auto_list_payments")],
        [InlineKeyboardButton("Удалить", callback_data="auto_remove_payment")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message.reply_text("Меню автоплатежей:", reply_markup=reply_markup)

async def auto_add_from_list(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Prompts to select a recipient for auto-payment from a predefined list."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    context.user_data['auto_payment_step'] = 'recipient_from_list'
    keyboard_buttons = []
    for key, value in RECIPIENT_WALLETS_SOL.items():
        keyboard_buttons.append([InlineKeyboardButton(f"Выбрать {key} ({str(value)[:4]}...{str(value)[-4:]})", callback_data=f"auto_select_recipient_{key}")])
    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message.reply_text("Выберите кошелек из списка для автоплатежа:", reply_markup=reply_markup)

async def request_auto_payment_schedule(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Prompts to select the schedule type for auto-payment."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    context.user_data['auto_payment_step'] = 'schedule_type'
    keyboard_buttons = [
        [InlineKeyboardButton("Каждые X минут", callback_data="auto_schedule_interval")],
        [InlineKeyboardButton("Ежедневно (в ЧЧ:ММ)", callback_data="auto_schedule_daily")],
        [InlineKeyboardButton("Ежемесячно (день ЧЧ:ММ)", callback_data="auto_schedule_monthly")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message.reply_text(
        f"Сумма `{context.user_data['temp_auto_payment_amount']:.8f} SOL` выбрана для `{escape_markdown_v2(context.user_data['temp_auto_payment_recipient_display'])}`\\.\n"
        "Выберите частоту автоплатежа:",
        parse_mode='MarkdownV2',
        reply_markup=reply_markup
    )

async def request_schedule_value(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Prompts for the specific value of the chosen schedule type."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    schedule_type = context.user_data['temp_auto_payment_schedule_type']
    context.user_data['auto_payment_step'] = 'schedule_value' # Set step to receive text input
    if schedule_type == 'interval':
        await message.reply_text("Введите количество минут между платежами (целое число):")
    elif schedule_type == 'daily':
        await message.reply_text("Введите время для ежедневного платежа в формате ЧЧ:ММ (например, 09:00 или 23:59):")
    elif schedule_type == 'monthly':
        await message.reply_text("Введите день месяца и время для ежемесячного платежа в формате 'день ЧЧ:ММ' (например, '15 10:30'):")
    else:
        await message.reply_text("Неизвестный тип расписания. Пожалуйста, попробуйте еще раз.", reply_markup=main_menu_keyboard)

async def confirm_add_auto_payment_details(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays a confirmation for the new auto-payment before final addition."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    # Generate a unique ID for the payment
    payment_id = f"auto_{uuid.uuid4().hex[:8]}"
    context.user_data['temp_auto_payment_id'] = payment_id # Store for confirmation

    recipient_pubkey_str = context.user_data['temp_auto_payment_recipient_pubkey']
    recipient_display_name = context.user_data['temp_auto_payment_recipient_display']
    amount_sol = context.user_data['temp_auto_payment_amount']
    schedule_type = context.user_data['temp_auto_payment_schedule_type']
    schedule_value = context.user_data['temp_auto_payment_schedule_value']
    schedule_display = context.user_data['temp_auto_payment_schedule_display'] # Pre-formatted display string

    confirmation_text = (
        f"Подтвердите создание автоплатежа:\n"
        f"  ID: `{escape_markdown_v2(payment_id)}`\n"
        f"  Получатель: `{escape_markdown_v2(recipient_display_name)}`\n"
        f"  Сумма: `{amount_sol:.8f} SOL`\n"
        f"  Расписание: `{escape_markdown_v2(schedule_display)}`\n"
        f"Подтверждаете?"
    )

    keyboard = [[InlineKeyboardButton("Подтвердить", callback_data=f"confirm_auto_payment_{payment_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message.reply_text(confirmation_text, parse_mode='MarkdownV2', reply_markup=reply_markup)

async def confirm_add_auto_payment(message, context: ContextTypes.DEFAULT_TYPE, payment_id: str) -> None:
    """Adds the auto-payment to storage and schedules it."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    # Verify the ID to prevent stale confirmations
    if 'temp_auto_payment_id' not in context.user_data or context.user_data['temp_auto_payment_id'] != payment_id:
        await message.reply_text("Ошибка подтверждения\\. Идентификатор платежа не совпадает\\. Пожалуйста, попробуйте начать сначала\\.", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        return

    # Retrieve and clear temporary data
    recipient_pubkey_str = context.user_data.pop('temp_auto_payment_recipient_pubkey')
    amount_sol = context.user_data.pop('temp_auto_payment_amount')
    schedule_type = context.user_data.pop('temp_auto_payment_schedule_type')
    schedule_value = context.user_data.pop('temp_auto_payment_schedule_value')
    context.user_data.pop('temp_auto_payment_recipient_display', None)
    context.user_data.pop('temp_auto_payment_schedule_display', None)
    context.user_data.pop('temp_auto_payment_id', None)
    context.user_data.pop('auto_payment_step', None) # Clear the auto-payment state

    chat_id = message.chat.id
    auto_payments = load_auto_payments()
    if str(chat_id) not in auto_payments:
        auto_payments[str(chat_id)] = {}

    payment_details = {
        "recipient_pubkey": PublicKey.from_string(recipient_pubkey_str),
        "amount_sol": amount_sol,
        "schedule": {
            "type": schedule_type,
            "value": schedule_value
        },
        "last_paid": None # Initialize last_paid to None
    }
    auto_payments[str(chat_id)][payment_id] = payment_details
    save_auto_payments(auto_payments)

    # Schedule the job with APScheduler
    job_id = f"{chat_id}_{payment_id}"
    if schedule_type == 'interval':
        minutes = int(schedule_value)
        scheduler.add_job(
            execute_auto_payment,
            IntervalTrigger(minutes=minutes),
            args=[context.application, chat_id, payment_id],
            id=job_id,
            replace_existing=True
        )
    elif schedule_type == 'daily':
        hour, minute = map(int, schedule_value.split(':'))
        scheduler.add_job(
            execute_auto_payment,
            CronTrigger(hour=hour, minute=minute),
            args=[context.application, chat_id, payment_id],
            id=job_id,
            replace_existing=True
        )
    elif schedule_type == 'monthly':
        day, time_str = schedule_value.split(' ', 1)
        day = int(day)
        hour, minute = map(int, time_str.split(':'))
        scheduler.add_job(
            execute_auto_payment,
            CronTrigger(day=day, hour=hour, minute=minute),
            args=[context.application, chat_id, payment_id],
            id=job_id,
            replace_existing=True
        )

    await message.reply_text(f"Автоплатеж `{escape_markdown_v2(payment_id)}` успешно добавлен и запланирован\\!", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
    logger.info(f"Auto-payment {payment_id} for chat {chat_id} added.")

async def list_auto_payments(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Lists all configured auto-payments for the current chat."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    chat_id = str(message.chat.id)
    auto_payments = load_auto_payments()

    payments = auto_payments.get(chat_id, {})
    if not payments:
        await message.reply_text("У вас пока нет настроенных автоматических платежей.", reply_markup=main_menu_keyboard)
        return

    response_text = "Ваши автоматические платежи:\n\n"
    for payment_id, details in payments.items():
        recipient_pubkey = details['recipient_pubkey']
        amount_sol = details['amount_sol']
        schedule_info = details['schedule']
        last_paid = details['last_paid'] if details['last_paid'] else "Никогда не выполнялся"

        # Try to find a friendly name, otherwise shorten the address
        display_name = next((k for k, v in RECIPIENT_WALLETS_SOL.items() if v == recipient_pubkey), str(recipient_pubkey)[:4] + '...' + str(recipient_pubkey)[-4:])

        schedule_display = ""
        if schedule_info['type'] == 'interval':
            schedule_display = f"каждые {schedule_info['value']} минут"
        elif schedule_info['type'] == 'daily':
            schedule_display = f"ежедневно в {schedule_info['value']}"
        elif schedule_info['type'] == 'monthly':
            parts = schedule_info['value'].split(' ', 1)
            day = parts[0]
            time_val = parts[1] if len(parts) > 1 else ""
            schedule_display = f"ежемесячно {day} числа в {time_val}"

        response_text += (
            f"ID: `{escape_markdown_v2(payment_id)}`\n"
            f"  Получатель: `{escape_markdown_v2(display_name)}`\n"
            f"  Сумма: `{amount_sol:.8f} SOL`\n"
            f"  Расписание: `{escape_markdown_v2(schedule_display)}`\n"
            f"  Последняя оплата: `{escape_markdown_v2(last_paid)}`\n\n"
        )
    await message.reply_text(response_text, parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)

async def remove_auto_payment_prompt(message, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Prompts the user to select an auto-payment to remove."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    chat_id = str(message.chat.id)
    auto_payments = load_auto_payments()

    payments = auto_payments.get(chat_id, {})
    if not payments:
        await message.reply_text("У вас нет настроенных автоматических платежей для удаления.", reply_markup=main_menu_keyboard)
        return

    keyboard_buttons = []
    for payment_id, details in payments.items():
        recipient_pubkey = details['recipient_pubkey']
        amount_sol = details['amount_sol']
        display_name = next((k for k, v in RECIPIENT_WALLETS_SOL.items() if v == recipient_pubkey), str(recipient_pubkey)[:4] + '...' + str(recipient_pubkey)[-4:])
        keyboard_buttons.append([InlineKeyboardButton(f"Удалить {payment_id} ({amount_sol:.2f} SOL на {display_name})", callback_data=f"delete_auto_payment_{payment_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message.reply_text("Выберите автоплатеж для удаления:", reply_markup=reply_markup)

async def delete_auto_payment(message, context: ContextTypes.DEFAULT_TYPE, payment_id_to_delete: str) -> None:
    """Deletes a selected auto-payment."""
    if not is_admin(message.chat.id):
        await message.reply_text("Извините, у вас нет доступа к этому боту.")
        return
    chat_id = str(message.chat.id)
    auto_payments = load_auto_payments()

    if chat_id in auto_payments and payment_id_to_delete in auto_payments[chat_id]:
        del auto_payments[chat_id][payment_id_to_delete]
        save_auto_payments(auto_payments)

        # Remove the job from the scheduler
        job_id = f"{chat_id}_{payment_id_to_delete}"
        if scheduler.get_job(job_id):
            scheduler.remove_job(job_id)
            logger.info(f"APScheduler job {job_id} removed.")

        await message.reply_text(f"Автоплатеж `{escape_markdown_v2(payment_id_to_delete)}` успешно удален\\.", parse_mode='MarkdownV2', reply_markup=main_menu_keyboard)
        logger.info(f"Auto-payment {payment_id_to_delete} for chat {chat_id} removed.")
    else:
        await message.reply_text("Автоплатеж не найден.", reply_markup=main_menu_keyboard)


# --- ЗАПУСК И НАСТРОЙКА БОТА ---
async def on_startup(app: Application):
    """Callback function executed on bot startup."""
    logger.info("on_startup: The on_startup function has been called.")
    logger.info(f"on_startup: Type of 'scheduler': {type(scheduler)}")
    logger.info(f"on_startup: 'scheduler' is callable: {callable(scheduler)}")

    if not scheduler.running:
        logger.info("on_startup: Starting APScheduler...")
        scheduler.start()
        logger.info("on_startup: APScheduler started.")
    else:
        logger.info("on_startup: APScheduler is already running.")

    await schedule_all_auto_payments(app)
    logger.info("on_startup: Auto-payments scheduled.")


def main() -> None:
    """Starts the bot."""
    initialize_solana()

    if not wallet_keypair:
        logger.critical("Bot cannot be started, wallet private key not loaded.")
        print(
            "Error: Bot cannot be started, wallet private key not loaded. Please check SENDER_SECRET_KEY_BYTES."
        )
        return

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).post_init(on_startup).build()

    logger.info("main: Type of 'on_startup' before run_polling: %s", type(on_startup))
    logger.info("main: 'on_startup' is callable before run_polling: %s", callable(on_startup))

    # Add a filter to process messages only from admins
    admin_filter = filters.Chat(chat_id=ADMIN_CHAT_IDS)

    application.add_handler(CommandHandler("start", start))
    # Handle general text messages from admins (excluding commands)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & admin_filter, handle_main_menu_buttons))
    application.add_handler(CallbackQueryHandler(inline_button_handler))


    logger.info("Bot started. Waiting for commands...")
    print("Bot started. Open Telegram and send /start.")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
